---
title: "Portfolio Optimization"
author: "Ivan Timothy Halim"
date: "12/2/2020"
output: github_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(here)
library(lubridate)
library(scales)
devtools::load_all()
```

# Portfolio Optimization

The problem is replicated from Zhu et al.(2011). The study employed a PSO algorithm for portfolio selection and optimization in investment management.

Portfolio optimization problem is concerned with managing the portfolio of assets that minimizes the risk objectives subjected to the constraint for guaranteeing a given level of returns. One of the fundamental principles of financial investment is diversification where investors diversify their investments into different types of assets. Portfolio diversification minimizes investors exposure to risks, and maximizes returns on portfolios.

The fitness function is the adjusted Sharpe Ratio for restricted portofolio, which combines the information from mean and variance of an asset and functioned as a risk-adjusted measure of mean return, which is often used to evaluate the performance of a portfolio.

The Sharpe ratio can help to explain whether a portfolio's excess returns are due to smart investment decisions or a result of too much risk. Although one portfolio or fund can enjoy higher returns than its peers, it is only a good investment if those higher returns do not come with an excess of additional risk.

The greater a portfolio's Sharpe ratio, the better its risk-adjusted performance. If the analysis results in a negative Sharpe ratio, it either means the risk-free rate is greater than the portfolio's return, or the portfolio's return is expected to be negative.

The fitness function is shown below:

$$
\max f(x) = \frac{\sum\limits_{i=1}^N W_i \ast r_i - R_f}{\sum\limits_{i=1}^N \sum\limits_{j=1}^N W_i \ast W_j \ast \sigma_{ij}}
$$

__Subject To__

$$
\sum\limits_{i=1}^N W_i = 1 \\
0 \leq W_i \leq 1 \\
i = 1,2,...,N
$$

* $N$: Number of different assets
* $W_i$: Weight of each stock in the portfolio
* $r_i$: Return of stock i
* $R_f$: The test available rate of return of a risk-free security (i.e. the interest rate on a three month U.S. Treasury bill)
* $\sigma_{ij}$: Covariance between returns of assets i and j

Adjusting the portfolio weights $w_i$, we can maximize the portfolio Sharpe Ratio in effect balancing the trade-off between maximizing the expected return and at the same time minimizing the risk.

## Import Data

Data is acquired from New York Stock Exchange on Kaggle ( https://www.kaggle.com/dgawlik/nyse ). We will only use data from January to March of 2015 for illustration.

* `date`: date
* `symbol`: symbol of company stock
* `open`: price at the open of the day
* `close`: price at the end of the day
* `low`: lowest price of the day
* `high`: highest price of the day
* `volume`: number of transaction at the day

```{r}
nyse <- read_csv(here("data", "prices.csv"))

nyse <- nyse %>%
    mutate(date = ymd(date)) %>%
    filter(year(date) == 2015,
           month(date) %in% c(1:3))
head(nyse)
```

To get clearer name of company, let's import the Ticker Symbol and Security.

```{r}
securities <- read_csv(here("Data", "securities.csv"))
securities <- securities %>%
    select(`Ticker symbol`, Security) %>%
    rename(stock = `Ticker symbol`)
head(securities)
```

Let's say I have assets in 3 different stocks. I will randomly choose the stocks.

```{r}
set.seed(13)
selected_stock <- sample(nyse$symbol, 3)

nyse <- nyse %>%
    filter(symbol %in% selected_stock)
head(nyse)
```

## Calculate Returns

Let's calculate the daily returns

```{r}
nyse <- nyse %>%
    select(date, symbol, close) %>%
    group_by(symbol) %>%
    rename(price = close) %>%
    mutate(price_prev = lag(price),
           returns = (price - price_prev)/price_prev) %>%
    slice(-1) %>%
    ungroup()

head(nyse)
```

Let's calculate the mean return of each stock

```{r}
mean_stock <- nyse %>%
    group_by(symbol) %>%
    summarise(mean = mean(returns))
head(mean_stock)
```

The value of $R_f$ is acquired from the latest interest rate on a three-month U.S. Treasury bill. Since the data is from 2016, we will use data from 2015 (Use data from March 27, 2015), which is 0.04%. The rate is acquired from https://ycharts.com/indicators/3_month_t_bill.

```{r}
rf <- 0.04/100
```

## Covariance Matrix Between Portofolio

Calculate the covariance matrix between portofolio. First, we need to separate the return of each portofolio into several column by spreading them.

```{r}
nyse_wide <- nyse %>%
    pivot_wider(id_cols = c(date, symbol), names_from = symbol, values_from = returns) %>%
    select(-date)

# Create Excess Return
for (symbol in unique(nyse$symbol)) {
    nyse_wide[symbol] <- nyse_wide[symbol] - as.numeric(mean_stock[mean_stock$symbol == symbol, "mean"])
}

head(nyse_wide)
```

Create the covariance matrix

```{r}
(nyse_cov <- cov(x = nyse_wide))
```

## Define Fitness Function

Let's define the fitness function. We will penalize the solution that violate the constraint. Higher penalty will increase accuracy and force the fitness value to get closer to the feasible area.

```{r}
sharpe_ratio <- function(W, noise=0) {
    
    # Calculate the numerator
    f1 <- W %*% mean_stock$mean
    
    # Calculate the denominator
    f2 <- numeric(length = nrow(W))
    for (i in 1:nrow(W)) {
      f2[i] <- sum(outer(W[i,], W[i,]) * nyse_cov)
    }
    
    # Calculate Fitness Value
    fitness <- (f1 - rf)/f2
    
    # Penalize Constraint Violation
    fitness <- fitness - 1e9 * (round(rowSums(W), 10) - 1)^2
    
    # Add noise
    fitness <- fitness + noise * rnorm(length(fitness))
    
    as.vector(fitness)
}
```

### Define Parameters

Let's define the search boundary

```{r}
lower <- rep(0, 3)
upper <- rep(1, 3)
```

Let's set the initial sample

```{r}
set.seed(123)
search_grid <- as.matrix(
                  data.frame(
                    w1 = runif(20,0,1),
                    w2 = runif(20,0,1),
                    w3 = runif(20,0,1)
                  )
                )

head(search_grid)
```

```{r}
BayesianOptimization <- function(FUN, lower, upper, init_grid_dt=NULL, init_points=1,
                                 n_iter=10, xi=0.01, noise=0, max=TRUE, acq=expected_improvement) {
  
  X_train <- init_grid_dt
  
  if (init_points > 0) {
    for (i in 1:init_points) {
      X <- runif(length(lower), lower, upper)
      rappend(X_train, t(X))
    }
  }
  
  Y_train <- FUN(X_train, noise)
  
  gpr <- gpr.init(sigma_y=noise)
  
  for (i in 1:n_iter) {
    # Update Gaussian process with existing samples
    gpr <- gpr.fit(X_train, Y_train, gpr)
    
    # Obtain next sampling point from the acquisition function
    X_next <- propose_location(acq, X_train, Y_train, gpr, lower, upper, xi=xi, max=max)
    
    # Obtain next noisy sample from the objective function
    Y_next <- FUN(t(X_next), noise)
    
    # Add sample to previous samples
    X_train <- rappend(X_train, X_next)
    Y_train <- rappend(Y_train, Y_next)
  }
  
  best_val <- ifelse(max, max(Y_train), min(Y_train))
  best_data <- data.frame(X_train, Y_train) %>%
    filter(Y_train == best_val)
  
  par <- unlist(best_data)[-ncol(best_data)]
  
  list("par" = par, "value" = best_val)
}
```

```{r}
bayes_finance_ei <- BayesianOptimization(FUN=sharpe_ratio, lower=lower, upper=upper,
                                         init_grid_dt=search_grid, init_points=10)
```

Result of the function consists of a list with 2 components:

* par: a vector of the best hyperparameter set found
* value: the value of metrics achieved by the best hyperparameter set

So, what is the optimum Sharpe Ratio from Bayesian optimization?

```{r}
bayes_finance_ei$value
```

The greater a portfolio's Sharpe ratio, the better its risk-adjusted performance. If the analysis results in a negative Sharpe ratio, it either means the risk-free rate is greater than the portfolio's return, or the portfolio's return is expected to be negative.

Let's check the total weight of the optimum result.

```{r}
sum(bayes_finance_ei$par)
```

Based on Bayesian Optimization, here is how your asset should be distributed.

```{r}
data.frame(stock = unique(nyse$symbol),
           weight = bayes_finance_ei$par) %>%
  arrange(desc(weight)) %>%
  mutate(weight = percent(weight, accuracy = 0.01)) %>%
  left_join(securities, by = "stock") %>%
  select(stock, Security, everything())
```